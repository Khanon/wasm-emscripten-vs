/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _webpack_emcc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webpack-emcc.mjs */ \"./src/webpack-emcc.mjs\");\n// Import WASM Module from preamble file\r\n\r\nconsole.log(\"Hello emscripten from Javascript\");\r\nlet wasmModule;\r\n/**\r\n * Create Wasm module (returns a Promise), then start the app\r\n */\r\n(0,_webpack_emcc_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then((module) => {\r\n    // Wasm module object\r\n    wasmModule = module;\r\n    console.log(\"Wasm module:\", module);\r\n    // Get HTML elements\r\n    getHTMLElements();\r\n    // Wrap exported functions from C++\r\n    registerFunctionPointer_updateTimer = module.cwrap('registerFunctionPointer_updateTimer', 'void', ['string']);\r\n    convertStringToAscii = module.cwrap('convertStringToAscii', 'number', ['string']);\r\n    // Export function to wasm module allowing using it from C++ code.\r\n    const importedFunctionId = module.addFunction(updateTimer, 'vi');\r\n    registerFunctionPointer_updateTimer(importedFunctionId.toString());\r\n}).catch(error => {\r\n    console.log(\"Error creating Wasm module:\", error);\r\n});\r\n/**\r\n * HTML elements\r\n */\r\nlet htmlCurrentTimerValue;\r\nlet htmlInputBox;\r\nlet htmlInputButton;\r\nlet htmlWasmResult;\r\n/**\r\n * Wrapped functions imported from C++\r\n */\r\nlet registerFunctionPointer_updateTimer;\r\nlet convertStringToAscii;\r\n/**\r\n* Get HTML elements\r\n*/\r\nconst getHTMLElements = () => {\r\n    htmlCurrentTimerValue = document.getElementById('current-time-value');\r\n    htmlInputBox = document.getElementById('input-box');\r\n    htmlInputButton = document.getElementById('input-button');\r\n    htmlWasmResult = document.getElementById('wasm-result');\r\n    // Initialize elements\r\n    htmlInputBox.value = 'Test me!';\r\n    htmlInputButton.onclick = inputButtonClick;\r\n};\r\n/**\r\n * Input button click\r\n */\r\nconst inputButtonClick = () => {\r\n    const str = htmlInputBox.value;\r\n    const ptr = convertStringToAscii(str);\r\n    htmlWasmResult.textContent = \"\";\r\n    for (let i = 0; i < str.length * 4; i += 4) {\r\n        htmlWasmResult.textContent += wasmModule.getValue(ptr + i, 'i32') + ' ';\r\n    }\r\n};\r\n/**\r\n * Update timer value from milliseconds in HTML\r\n */\r\nconst updateTimer = (milliseconds) => {\r\n    let mms = Math.floor((milliseconds % 1000) / 100);\r\n    let sec = Math.floor((milliseconds / 1000) % 60);\r\n    let min = Math.floor((milliseconds / (1000 * 60)) % 60);\r\n    let hours = Math.floor((milliseconds / (1000 * 60 * 60)) % 24);\r\n    htmlCurrentTimerValue.innerText = `${hours}:${min}:${sec}.${mms}`;\r\n};\r\n\n\n//# sourceURL=webpack://webpack-project/./src/app.ts?");

/***/ }),

/***/ "./src/webpack-emcc.wasm":
/*!*******************************!*\
  !*** ./src/webpack-emcc.wasm ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"37f4c7eb4088be14e565.wasm\";\n\n//# sourceURL=webpack://webpack-project/./src/webpack-emcc.wasm?");

/***/ }),

/***/ "./src/webpack-emcc.mjs":
/*!******************************!*\
  !*** ./src/webpack-emcc.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\nvar Module = (() => {\r\n  var _scriptDir = \"file:///C:/Proyectos/wasm-emscripten-vs/webpack-project/src/webpack-emcc.mjs\";\r\n  \r\n  return (\r\nfunction(Module) {\r\n  Module = Module || {};\r\n\r\n\r\n\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module != 'undefined' ? Module : {};\r\n\r\n// See https://caniuse.com/mdn-javascript_builtins_object_assign\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\nModule['ready'] = new Promise(function(resolve, reject) {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n\r\n      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_main')) {\r\n        Object.defineProperty(Module['ready'], '_main', { configurable: true, get: function() { abort('You are getting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n        Object.defineProperty(Module['ready'], '_main', { configurable: true, set: function() { abort('You are setting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n      }\r\n    \r\n\r\n      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_registerFunctionPointer_updateTimer')) {\r\n        Object.defineProperty(Module['ready'], '_registerFunctionPointer_updateTimer', { configurable: true, get: function() { abort('You are getting _registerFunctionPointer_updateTimer on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n        Object.defineProperty(Module['ready'], '_registerFunctionPointer_updateTimer', { configurable: true, set: function() { abort('You are setting _registerFunctionPointer_updateTimer on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n      }\r\n    \r\n\r\n      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_convertStringToAscii')) {\r\n        Object.defineProperty(Module['ready'], '_convertStringToAscii', { configurable: true, get: function() { abort('You are getting _convertStringToAscii on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n        Object.defineProperty(Module['ready'], '_convertStringToAscii', { configurable: true, set: function() { abort('You are setting _convertStringToAscii on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n      }\r\n    \r\n\r\n      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fflush')) {\r\n        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, get: function() { abort('You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, set: function() { abort('You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n      }\r\n    \r\n\r\n      if (!Object.getOwnPropertyDescriptor(Module['ready'], 'onRuntimeInitialized')) {\r\n        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, get: function() { abort('You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, set: function() { abort('You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\r\n      }\r\n    \r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n// {{PRE_JSES}}\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\n// Attempt to auto-detect the environment\r\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\r\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\r\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n// also a web environment.\r\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\r\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nif (Module['ENVIRONMENT']) {\r\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\r\n}\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar read_,\r\n    readAsync,\r\n    readBinary,\r\n    setWindowTitle;\r\n\r\n// Normally we don't log exceptions but instead let them bubble out the top\r\n// level where the embedding environment (e.g. the browser) can handle\r\n// them.\r\n// However under v8 and node we sometimes exit the process direcly in which case\r\n// its up to use us to log the exception before exiting.\r\n// If we fix https://github.com/emscripten-core/emscripten/issues/15080\r\n// this may no longer be needed under node.\r\nfunction logExceptionOnExit(e) {\r\n  if (e instanceof ExitStatus) return;\r\n  let toLog = e;\r\n  if (e && typeof e == 'object' && e.stack) {\r\n    toLog = [e, e.stack];\r\n  }\r\n  err('exiting due to exception: ' + toLog);\r\n}\r\n\r\nvar fs;\r\nvar nodePath;\r\nvar requireNodeFS;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  if (!(typeof process == 'object' && typeof require == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    scriptDirectory = require('path').dirname(scriptDirectory) + '/';\r\n  } else {\r\n    scriptDirectory = __dirname + '/';\r\n  }\r\n\r\n// include: node_shell_read.js\r\n\r\n\r\nrequireNodeFS = () => {\r\n  // Use nodePath as the indicator for these not being initialized,\r\n  // since in some environments a global fs may have already been\r\n  // created.\r\n  if (!nodePath) {\r\n    fs = require('fs');\r\n    nodePath = require('path');\r\n  }\r\n};\r\n\r\nread_ = function shell_read(filename, binary) {\r\n  requireNodeFS();\r\n  filename = nodePath['normalize'](filename);\r\n  return fs.readFileSync(filename, binary ? undefined : 'utf8');\r\n};\r\n\r\nreadBinary = (filename) => {\r\n  var ret = read_(filename, true);\r\n  if (!ret.buffer) {\r\n    ret = new Uint8Array(ret);\r\n  }\r\n  assert(ret.buffer);\r\n  return ret;\r\n};\r\n\r\nreadAsync = (filename, onload, onerror) => {\r\n  requireNodeFS();\r\n  filename = nodePath['normalize'](filename);\r\n  fs.readFile(filename, function(err, data) {\r\n    if (err) onerror(err);\r\n    else onload(data.buffer);\r\n  });\r\n};\r\n\r\n// end include: node_shell_read.js\r\n  if (process['argv'].length > 1) {\r\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\r\n  }\r\n\r\n  arguments_ = process['argv'].slice(2);\r\n\r\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\r\n\r\n  process['on']('uncaughtException', function(ex) {\r\n    // suppress ExitStatus exceptions from showing an error\r\n    if (!(ex instanceof ExitStatus)) {\r\n      throw ex;\r\n    }\r\n  });\r\n\r\n  // Without this older versions of node (< v15) will log unhandled rejections\r\n  // but return 0, which is not normally the desired behaviour.  This is\r\n  // not be needed with node v15 and about because it is now the default\r\n  // behaviour:\r\n  // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode\r\n  process['on']('unhandledRejection', function(reason) { throw reason; });\r\n\r\n  quit_ = (status, toThrow) => {\r\n    if (keepRuntimeAlive()) {\r\n      process['exitCode'] = status;\r\n      throw toThrow;\r\n    }\r\n    logExceptionOnExit(toThrow);\r\n    process['exit'](status);\r\n  };\r\n\r\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\r\n\r\n} else\r\nif (ENVIRONMENT_IS_SHELL) {\r\n\r\n  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  if (typeof read != 'undefined') {\r\n    read_ = function shell_read(f) {\r\n      return read(f);\r\n    };\r\n  }\r\n\r\n  readBinary = function readBinary(f) {\r\n    let data;\r\n    if (typeof readbuffer == 'function') {\r\n      return new Uint8Array(readbuffer(f));\r\n    }\r\n    data = read(f, 'binary');\r\n    assert(typeof data == 'object');\r\n    return data;\r\n  };\r\n\r\n  readAsync = function readAsync(f, onload, onerror) {\r\n    setTimeout(() => onload(readBinary(f)), 0);\r\n  };\r\n\r\n  if (typeof scriptArgs != 'undefined') {\r\n    arguments_ = scriptArgs;\r\n  } else if (typeof arguments != 'undefined') {\r\n    arguments_ = arguments;\r\n  }\r\n\r\n  if (typeof quit == 'function') {\r\n    quit_ = (status, toThrow) => {\r\n      logExceptionOnExit(toThrow);\r\n      quit(status);\r\n    };\r\n  }\r\n\r\n  if (typeof print != 'undefined') {\r\n    // Prefer to use print/printErr where they exist, as they usually work better.\r\n    if (typeof console == 'undefined') console = /** @type{!Console} */({});\r\n    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\r\n    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);\r\n  }\r\n\r\n} else\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\r\n  // is gone, so we saved it, and we use it here instead of any other info.\r\n  if (_scriptDir) {\r\n    scriptDirectory = _scriptDir;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.indexOf('blob:') !== 0) {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\r\n  } else {\r\n    scriptDirectory = '';\r\n  }\r\n\r\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  // Differentiate the Web Worker from the Node Worker case, as reading must\r\n  // be done differently.\r\n  {\r\n// include: web_or_worker_shell_read.js\r\n\r\n\r\n  read_ = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText;\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, false);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.send(null);\r\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = (url, onload, onerror) => {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = () => {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  }\r\n\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n\r\n  setWindowTitle = (title) => document.title = title;\r\n} else\r\n{\r\n  throw new Error('environment detection error');\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.warn.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = null;\r\ncheckIncomingModuleAPI();\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\r\n\r\nif (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n// Assertions on removed incoming Module JS APIs.\r\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');\r\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\r\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\r\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\r\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\r\nlegacyModuleProp('read', 'read_');\r\nlegacyModuleProp('readAsync', 'readAsync');\r\nlegacyModuleProp('readBinary', 'readBinary');\r\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\r\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\r\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\r\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\r\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\r\nfunction alignMemory() { abort('`alignMemory` is now a library function and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line'); }\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\r\n\r\n\r\n\r\n\r\nvar STACK_ALIGN = 16;\r\nvar POINTER_SIZE = 4;\r\n\r\nfunction getNativeTypeSize(type) {\r\n  switch (type) {\r\n    case 'i1': case 'i8': case 'u8': return 1;\r\n    case 'i16': case 'u16': return 2;\r\n    case 'i32': case 'u32': return 4;\r\n    case 'i64': case 'u64': return 8;\r\n    case 'float': return 4;\r\n    case 'double': return 8;\r\n    default: {\r\n      if (type[type.length - 1] === '*') {\r\n        return POINTER_SIZE;\r\n      } else if (type[0] === 'i') {\r\n        const bits = Number(type.substr(1));\r\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\r\n        return bits / 8;\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnce(text) {\r\n  if (!warnOnce.shown) warnOnce.shown = {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    err(text);\r\n  }\r\n}\r\n\r\n// include: runtime_functions.js\r\n\r\n\r\n// This gives correct answers for everything less than 2^{14} = 16384\r\n// I hope nobody is contemplating functions with 16384 arguments...\r\nfunction uleb128Encode(n) {\r\n  assert(n < 16384);\r\n  if (n < 128) {\r\n    return [n];\r\n  }\r\n  return [(n % 128) | 128, n >> 7];\r\n}\r\n\r\n// Converts a signature like 'vii' into a description of the wasm types, like\r\n// { parameters: ['i32', 'i32'], results: [] }.\r\nfunction sigToWasmTypes(sig) {\r\n  var typeNames = {\r\n    'i': 'i32',\r\n    'j': 'i64',\r\n    'f': 'f32',\r\n    'd': 'f64',\r\n    'p': 'i32',\r\n  };\r\n  var type = {\r\n    parameters: [],\r\n    results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\r\n  };\r\n  for (var i = 1; i < sig.length; ++i) {\r\n    assert(sig[i] in typeNames, 'invalid signature char: ' + sig[i]);\r\n    type.parameters.push(typeNames[sig[i]]);\r\n  }\r\n  return type;\r\n}\r\n\r\n// Wraps a JS function as a wasm function with a given signature.\r\nfunction convertJsFunctionToWasm(func, sig) {\r\n\r\n  // If the type reflection proposal is available, use the new\r\n  // \"WebAssembly.Function\" constructor.\r\n  // Otherwise, construct a minimal wasm module importing the JS function and\r\n  // re-exporting it.\r\n  if (typeof WebAssembly.Function == \"function\") {\r\n    return new WebAssembly.Function(sigToWasmTypes(sig), func);\r\n  }\r\n\r\n  // The module is static, with the exception of the type section, which is\r\n  // generated based on the signature passed in.\r\n  var typeSection = [\r\n    0x01, // count: 1\r\n    0x60, // form: func\r\n  ];\r\n  var sigRet = sig.slice(0, 1);\r\n  var sigParam = sig.slice(1);\r\n  var typeCodes = {\r\n    'i': 0x7f, // i32\r\n    'p': 0x7f, // i32\r\n    'j': 0x7e, // i64\r\n    'f': 0x7d, // f32\r\n    'd': 0x7c, // f64\r\n  };\r\n\r\n  // Parameters, length + signatures\r\n  typeSection = typeSection.concat(uleb128Encode(sigParam.length));\r\n  for (var i = 0; i < sigParam.length; ++i) {\r\n    assert(sigParam[i] in typeCodes, 'invalid signature char: ' + sigParam[i]);\r\n    typeSection.push(typeCodes[sigParam[i]]);\r\n  }\r\n\r\n  // Return values, length + signatures\r\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\r\n  if (sigRet == 'v') {\r\n    typeSection.push(0x00);\r\n  } else {\r\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\r\n  }\r\n\r\n  // Write the section code and overall length of the type section into the\r\n  // section header\r\n  typeSection = [0x01 /* Type section code */].concat(\r\n    uleb128Encode(typeSection.length),\r\n    typeSection\r\n  );\r\n\r\n  // Rest of the module is static\r\n  var bytes = new Uint8Array([\r\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\r\n    0x01, 0x00, 0x00, 0x00, // version: 1\r\n  ].concat(typeSection, [\r\n    0x02, 0x07, // import section\r\n      // (import \"e\" \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\r\n    0x07, 0x05, // export section\r\n      // (export \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x66, 0x00, 0x00,\r\n  ]));\r\n\r\n   // We can compile this wasm module synchronously because it is very small.\r\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\r\n  var module = new WebAssembly.Module(bytes);\r\n  var instance = new WebAssembly.Instance(module, {\r\n    'e': {\r\n      'f': func\r\n    }\r\n  });\r\n  var wrappedFunc = instance.exports['f'];\r\n  return wrappedFunc;\r\n}\r\n\r\nvar freeTableIndexes = [];\r\n\r\n// Weak map of functions in the table to their indexes, created on first use.\r\nvar functionsInTableMap;\r\n\r\nfunction getEmptyTableSlot() {\r\n  // Reuse a free index if there is one, otherwise grow.\r\n  if (freeTableIndexes.length) {\r\n    return freeTableIndexes.pop();\r\n  }\r\n  // Grow the table\r\n  try {\r\n    wasmTable.grow(1);\r\n  } catch (err) {\r\n    if (!(err instanceof RangeError)) {\r\n      throw err;\r\n    }\r\n    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\r\n  }\r\n  return wasmTable.length - 1;\r\n}\r\n\r\nfunction updateTableMap(offset, count) {\r\n  for (var i = offset; i < offset + count; i++) {\r\n    var item = getWasmTableEntry(i);\r\n    // Ignore null values.\r\n    if (item) {\r\n      functionsInTableMap.set(item, i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Add a function to the table.\r\n * 'sig' parameter is required if the function being added is a JS function.\r\n * @param {string=} sig\r\n */\r\nfunction addFunction(func, sig) {\r\n  assert(typeof func != 'undefined');\r\n\r\n  // Check if the function is already in the table, to ensure each function\r\n  // gets a unique index. First, create the map if this is the first use.\r\n  if (!functionsInTableMap) {\r\n    functionsInTableMap = new WeakMap();\r\n    updateTableMap(0, wasmTable.length);\r\n  }\r\n  if (functionsInTableMap.has(func)) {\r\n    return functionsInTableMap.get(func);\r\n  }\r\n\r\n  // It's not in the table, add it now.\r\n\r\n  var ret = getEmptyTableSlot();\r\n\r\n  // Set the new value.\r\n  try {\r\n    // Attempting to call this with JS function will cause of table.set() to fail\r\n    setWasmTableEntry(ret, func);\r\n  } catch (err) {\r\n    if (!(err instanceof TypeError)) {\r\n      throw err;\r\n    }\r\n    assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);\r\n    var wrapped = convertJsFunctionToWasm(func, sig);\r\n    setWasmTableEntry(ret, wrapped);\r\n  }\r\n\r\n  functionsInTableMap.set(func, ret);\r\n\r\n  return ret;\r\n}\r\n\r\nfunction removeFunction(index) {\r\n  functionsInTableMap.delete(getWasmTableEntry(index));\r\n  freeTableIndexes.push(index);\r\n}\r\n\r\n// end include: runtime_functions.js\r\n// include: runtime_debug.js\r\n\r\n\r\nfunction legacyModuleProp(prop, newName) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    Object.defineProperty(Module, prop, {\r\n      configurable: true,\r\n      get: function() {\r\n        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ignoredModuleProp(prop) {\r\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');\r\n  }\r\n}\r\n\r\nfunction unexportedMessage(sym, isFSSybol) {\r\n  var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\";\r\n  if (isFSSybol) {\r\n    msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n  }\r\n  return msg;\r\n}\r\n\r\nfunction unexportedRuntimeSymbol(sym, isFSSybol) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Object.defineProperty(Module, sym, {\r\n      configurable: true,\r\n      get: function() {\r\n        abort(unexportedMessage(sym, isFSSybol));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction unexportedRuntimeFunction(sym, isFSSybol) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Module[sym] = () => abort(unexportedMessage(sym, isFSSybol));\r\n  }\r\n}\r\n\r\n// end include: runtime_debug.js\r\nvar tempRet0 = 0;\r\nvar setTempRet0 = (value) => { tempRet0 = value; };\r\nvar getTempRet0 = () => tempRet0;\r\n\r\n\r\n\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary;\r\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\r\nvar noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  abort('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort('Assertion failed' + (text ? ': ' + text : ''));\r\n  }\r\n}\r\n\r\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\r\nfunction getCFunc(ident) {\r\n  var func = Module['_' + ident]; // closure exported function\r\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\r\n  return func;\r\n}\r\n\r\n// C calling interface.\r\n/** @param {string|null=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Arguments|Array=} args\r\n    @param {Object=} opts */\r\nfunction ccall(ident, returnType, argTypes, args, opts) {\r\n  // For fast lookup of conversion functions\r\n  var toC = {\r\n    'string': function(str) {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) { // null string\r\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\r\n        var len = (str.length << 2) + 1;\r\n        ret = stackAlloc(len);\r\n        stringToUTF8(str, ret, len);\r\n      }\r\n      return ret;\r\n    },\r\n    'array': function(arr) {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret;\r\n    }\r\n  };\r\n\r\n  function convertReturnValue(ret) {\r\n    if (returnType === 'string') {\r\n      \r\n      return UTF8ToString(ret);\r\n    }\r\n    if (returnType === 'boolean') return Boolean(ret);\r\n    return ret;\r\n  }\r\n\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func.apply(null, cArgs);\r\n  function onDone(ret) {\r\n    if (stack !== 0) stackRestore(stack);\r\n    return convertReturnValue(ret);\r\n  }\r\n\r\n  ret = onDone(ret);\r\n  return ret;\r\n}\r\n\r\n/** @param {string=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Object=} opts */\r\nfunction cwrap(ident, returnType, argTypes, opts) {\r\n  return function() {\r\n    return ccall(ident, returnType, argTypes, arguments, opts);\r\n  }\r\n}\r\n\r\n// We used to include malloc/free by default in the past. Show a helpful error in\r\n// builds with assertions.\r\nfunction _malloc() {\r\n  abort(\"malloc() called but not included in the build - add '_malloc' to EXPORTED_FUNCTIONS\");\r\n}\r\nfunction _free() {\r\n  // Show a helpful error since we used to include free by default in the past.\r\n  abort(\"free() called but not included in the build - add '_free' to EXPORTED_FUNCTIONS\");\r\n}\r\n\r\n// include: runtime_legacy.js\r\n\r\n\r\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\r\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\r\n\r\n/**\r\n * allocate(): This function is no longer used by emscripten but is kept around to avoid\r\n *             breaking external users.\r\n *             You should normally not use allocate(), and instead allocate\r\n *             memory using _malloc()/stackAlloc(), initialize it with\r\n *             setValue(), and so forth.\r\n * @param {(Uint8Array|Array<number>)} slab: An array of data.\r\n * @param {number=} allocator : How to allocate memory, see ALLOC_*\r\n */\r\nfunction allocate(slab, allocator) {\r\n  var ret;\r\n  assert(typeof allocator == 'number', 'allocate no longer takes a type argument')\r\n  assert(typeof slab != 'number', 'allocate no longer takes a number as arg0')\r\n\r\n  if (allocator == ALLOC_STACK) {\r\n    ret = stackAlloc(slab.length);\r\n  } else {\r\n    ret = abort('malloc was not included, but is needed in allocate. Adding \"_malloc\" to EXPORTED_FUNCTIONS should fix that. This may be a bug in the compiler, please file an issue.');;\r\n  }\r\n\r\n  if (!slab.subarray && !slab.slice) {\r\n    slab = new Uint8Array(slab);\r\n  }\r\n  HEAPU8.set(slab, ret);\r\n  return ret;\r\n}\r\n\r\n// end include: runtime_legacy.js\r\n// include: runtime_strings.js\r\n\r\n\r\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\r\n\r\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\r\n// a copy of that string as a Javascript String object.\r\n/**\r\n * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n * @param {number} idx\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\r\n  var endIdx = idx + maxBytesToRead;\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\r\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n\r\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n  } else {\r\n    var str = '';\r\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\r\n    while (idx < endPtr) {\r\n      // For UTF8 byte structure, see:\r\n      // http://en.wikipedia.org/wiki/UTF-8#Description\r\n      // https://www.ietf.org/rfc/rfc2279.txt\r\n      // https://tools.ietf.org/html/rfc3629\r\n      var u0 = heapOrArray[idx++];\r\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n      var u1 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n      var u2 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xF0) == 0xE0) {\r\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n      } else {\r\n        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\r\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n      }\r\n\r\n      if (u0 < 0x10000) {\r\n        str += String.fromCharCode(u0);\r\n      } else {\r\n        var ch = u0 - 0x10000;\r\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\r\n// copy of that string as a Javascript String object.\r\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\r\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\r\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\r\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\r\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\r\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\r\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\r\n//                 style or the other.\r\n/**\r\n * @param {number} ptr\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ToString(ptr, maxBytesToRead) {\r\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\r\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\r\n//   outIdx: The starting offset in the array to begin the copying.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\r\n//                    This count should include the null terminator,\r\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\r\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\r\n    return 0;\r\n\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) {\r\n      var u1 = str.charCodeAt(++i);\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      if (outIdx >= endIdx) break;\r\n      heap[outIdx++] = u;\r\n    } else if (u <= 0x7FF) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      heap[outIdx++] = 0xC0 | (u >> 6);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0xFFFF) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      heap[outIdx++] = 0xE0 | (u >> 12);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\r\n      heap[outIdx++] = 0xF0 | (u >> 18);\r\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  heap[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\r\nfunction lengthBytesUTF8(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    if (u <= 0x7F) ++len;\r\n    else if (u <= 0x7FF) len += 2;\r\n    else if (u <= 0xFFFF) len += 3;\r\n    else len += 4;\r\n  }\r\n  return len;\r\n}\r\n\r\n// end include: runtime_strings.js\r\n// include: runtime_strings_extra.js\r\n\r\n\r\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\r\n\r\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction AsciiToString(ptr) {\r\n  var str = '';\r\n  while (1) {\r\n    var ch = HEAPU8[((ptr++)>>0)];\r\n    if (!ch) return str;\r\n    str += String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\r\n\r\nfunction stringToAscii(str, outPtr) {\r\n  return writeAsciiToMemory(str, outPtr, false);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\r\n\r\nfunction UTF16ToString(ptr, maxBytesToRead) {\r\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  var maxIdx = idx + maxBytesToRead / 2;\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n\r\n  if (endPtr - ptr > 32 && UTF16Decoder) {\r\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  } else {\r\n    var str = '';\r\n\r\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\r\n    // will always evaluate to true. The loop is then terminated on the first null char.\r\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n      if (codeUnit == 0) break;\r\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\r\n      str += String.fromCharCode(codeUnit);\r\n    }\r\n\r\n    return str;\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2; // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    HEAP16[((outPtr)>>1)] = codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP16[((outPtr)>>1)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF16(str) {\r\n  return str.length*2;\r\n}\r\n\r\nfunction UTF32ToString(ptr, maxBytesToRead) {\r\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\r\n  var i = 0;\r\n\r\n  var str = '';\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(i >= maxBytesToRead / 4)) {\r\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n    if (utf32 == 0) break;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 0x10000) {\r\n      var ch = utf32 - 0x10000;\r\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n    }\r\n    HEAP32[((outPtr)>>2)] = codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP32[((outPtr)>>2)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF32(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// Allocate heap space for a JS string, and write it there.\r\n// It is the responsibility of the caller to free() that memory.\r\nfunction allocateUTF8(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = abort('malloc was not included, but is needed in allocateUTF8. Adding \"_malloc\" to EXPORTED_FUNCTIONS should fix that. This may be a bug in the compiler, please file an issue.');;\r\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Allocate stack space for a JS string, and write it there.\r\nfunction allocateUTF8OnStack(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Deprecated: This function should not be called because it is unsafe and does not provide\r\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\r\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\r\n// to be secure from out of bounds writes.\r\n/** @deprecated\r\n    @param {boolean=} dontAddNull */\r\nfunction writeStringToMemory(string, buffer, dontAddNull) {\r\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\r\n\r\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\r\n  if (dontAddNull) {\r\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\r\n    // character that existed at the location where the null will be placed, and restore\r\n    // that after the write (below).\r\n    end = buffer + lengthBytesUTF8(string);\r\n    lastChar = HEAP8[end];\r\n  }\r\n  stringToUTF8(string, buffer, Infinity);\r\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\r\n  HEAP8.set(array, buffer);\r\n}\r\n\r\n/** @param {boolean=} dontAddNull */\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n  for (var i = 0; i < str.length; ++i) {\r\n    assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\r\n    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\r\n}\r\n\r\n// end include: runtime_strings_extra.js\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!ArrayBuffer} */\r\n  buffer,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateGlobalBufferAndViews(buf) {\r\n  buffer = buf;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\r\n}\r\n\r\nvar TOTAL_STACK = 5242880;\r\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\r\n\r\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');\r\n\r\nassert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\r\n\r\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\r\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\r\n       'JS engine does not provide full typed array support');\r\n\r\n// If memory is defined in wasm, the user can't provide it.\r\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\r\nassert(INITIAL_MEMORY == 16777216, 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\r\n\r\n// include: runtime_init_table.js\r\n// In regular non-RELOCATABLE mode the table is exported\r\n// from the wasm module and this will be assigned once\r\n// the exports are available.\r\nvar wasmTable;\r\n\r\n// end include: runtime_init_table.js\r\n// include: runtime_stack_check.js\r\n\r\n\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  var max = _emscripten_stack_get_end();\r\n  assert((max & 3) == 0);\r\n  // The stack grow downwards towards _emscripten_stack_get_end.\r\n  // We write cookies to the final two words in the stack and detect if they are\r\n  // ever overwritten.\r\n  HEAP32[((max)>>2)] = 0x2135467;\r\n  HEAP32[(((max)+(4))>>2)] = 0x89BACDFE;\r\n  // Also test the global address 0 for integrity.\r\n  HEAPU32[0] = 0x63736d65; /* 'emsc' */\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (ABORT) return;\r\n  var max = _emscripten_stack_get_end();\r\n  var cookie1 = HEAPU32[((max)>>2)];\r\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\r\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\r\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (HEAPU32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\r\n}\r\n\r\n// end include: runtime_stack_check.js\r\n// include: runtime_assertions.js\r\n\r\n\r\n// Endianness check\r\n(function() {\r\n  var h16 = new Int16Array(1);\r\n  var h8 = new Int8Array(h16.buffer);\r\n  h16[0] = 0x6373;\r\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\r\n})();\r\n\r\n// end include: runtime_assertions.js\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATMAIN__    = []; // functions called when main() is to be run\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\n\r\nfunction keepRuntimeAlive() {\r\n  return noExitRuntime;\r\n}\r\n\r\nfunction preRun() {\r\n\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  assert(!runtimeInitialized);\r\n  runtimeInitialized = true;\r\n\r\n  checkStackCookie();\r\n\r\n  \r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction preMain() {\r\n  checkStackCookie();\r\n  \r\n  callRuntimeCallbacks(__ATMAIN__);\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPreMain(cb) {\r\n  __ATMAIN__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// include: runtime_math.js\r\n\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n\r\n// end include: runtime_math.js\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(function() {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err('still waiting on run dependencies:');\r\n          }\r\n          err('dependency: ' + dep);\r\n        }\r\n        if (shown) {\r\n          err('(end of list)');\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    err('warning: run dependency added without ID');\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err('warning: run dependency removed without ID');\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  {\r\n    if (Module['onAbort']) {\r\n      Module['onAbort'](what);\r\n    }\r\n  }\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\n// {{MEM_INITIALIZER}}\r\n\r\n// include: memoryprofiler.js\r\n\r\n\r\n// end include: memoryprofiler.js\r\n// show errors on likely calls to FS when it was not included\r\nvar FS = {\r\n  error: function() {\r\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\r\n  },\r\n  init: function() { FS.error() },\r\n  createDataFile: function() { FS.error() },\r\n  createPreloadedFile: function() { FS.error() },\r\n  createLazyFile: function() { FS.error() },\r\n  open: function() { FS.error() },\r\n  mkdev: function() { FS.error() },\r\n  registerDevice: function() { FS.error() },\r\n  analyzePath: function() { FS.error() },\r\n  loadFilesFromDB: function() { FS.error() },\r\n\r\n  ErrnoError: function ErrnoError() { FS.error() },\r\n};\r\nModule['FS_createDataFile'] = FS.createDataFile;\r\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\r\n\r\n// include: URIUtils.js\r\n\r\n\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\r\n  return filename.startsWith(dataURIPrefix);\r\n}\r\n\r\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\nfunction isFileURI(filename) {\r\n  return filename.startsWith('file://');\r\n}\r\n\r\n// end include: URIUtils.js\r\n/** @param {boolean=} fixedasm */\r\nfunction createExportWrapper(name, fixedasm) {\r\n  return function() {\r\n    var displayName = name;\r\n    var asm = fixedasm;\r\n    if (!fixedasm) {\r\n      asm = Module['asm'];\r\n    }\r\n    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');\r\n    if (!asm[name]) {\r\n      assert(asm[name], 'exported native function `' + displayName + '` not found');\r\n    }\r\n    return asm[name].apply(null, arguments);\r\n  };\r\n}\r\n\r\nvar wasmBinaryFile;\r\nif (Module['locateFile']) {\r\n  wasmBinaryFile = 'webpack-emcc.wasm';\r\n  if (!isDataURI(wasmBinaryFile)) {\r\n    wasmBinaryFile = locateFile(wasmBinaryFile);\r\n  }\r\n} else {\r\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n  wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! webpack-emcc.wasm */ \"./src/webpack-emcc.wasm\"), __webpack_require__.b).toString();\r\n}\r\n\r\nfunction getBinary(file) {\r\n  try {\r\n    if (file == wasmBinaryFile && wasmBinary) {\r\n      return new Uint8Array(wasmBinary);\r\n    }\r\n    if (readBinary) {\r\n      return readBinary(file);\r\n    } else {\r\n      throw \"both async and sync fetching of the wasm failed\";\r\n    }\r\n  }\r\n  catch (err) {\r\n    abort(err);\r\n  }\r\n}\r\n\r\nfunction getBinaryPromise() {\r\n  // If we don't have the binary yet, try to to load it asynchronously.\r\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n  // Cordova or Electron apps are typically loaded from a file:// url.\r\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\r\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n    if (typeof fetch == 'function'\r\n      && !isFileURI(wasmBinaryFile)\r\n    ) {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        if (!response['ok']) {\r\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n        }\r\n        return response['arrayBuffer']();\r\n      }).catch(function () {\r\n          return getBinary(wasmBinaryFile);\r\n      });\r\n    }\r\n    else {\r\n      if (readAsync) {\r\n        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\r\n        return new Promise(function(resolve, reject) {\r\n          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Otherwise, getBinary should be able to get it synchronously\r\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm() {\r\n  // prepare imports\r\n  var info = {\r\n    'env': asmLibraryArg,\r\n    'wasi_snapshot_preview1': asmLibraryArg,\r\n  };\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    var exports = instance.exports;\r\n\r\n    Module['asm'] = exports;\r\n\r\n    wasmMemory = Module['asm']['memory'];\r\n    assert(wasmMemory, \"memory not found in wasm exports\");\r\n    // This assertion doesn't hold when emscripten is run in --post-link\r\n    // mode.\r\n    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\r\n    //assert(wasmMemory.buffer.byteLength === 16777216);\r\n    updateGlobalBufferAndViews(wasmMemory.buffer);\r\n\r\n    wasmTable = Module['asm']['__indirect_function_table'];\r\n    assert(wasmTable, \"table not found in wasm exports\");\r\n\r\n    addOnInit(Module['asm']['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n\r\n  }\r\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n    trueModule = null;\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\r\n    receiveInstance(result['instance']);\r\n  }\r\n\r\n  function instantiateArrayBuffer(receiver) {\r\n    return getBinaryPromise().then(function(binary) {\r\n      return WebAssembly.instantiate(binary, info);\r\n    }).then(function (instance) {\r\n      return instance;\r\n    }).then(receiver, function(reason) {\r\n      err('failed to asynchronously prepare wasm: ' + reason);\r\n\r\n      // Warn on some common problems.\r\n      if (isFileURI(wasmBinaryFile)) {\r\n        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');\r\n      }\r\n      abort(reason);\r\n    });\r\n  }\r\n\r\n  function instantiateAsync() {\r\n    if (!wasmBinary &&\r\n        typeof WebAssembly.instantiateStreaming == 'function' &&\r\n        !isDataURI(wasmBinaryFile) &&\r\n        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\r\n        !isFileURI(wasmBinaryFile) &&\r\n        // Avoid instantiateStreaming() on Node.js environment for now, as while\r\n        // Node.js v18.1.0 implements it, it does not have a full fetch()\r\n        // implementation yet.\r\n        //\r\n        // Reference:\r\n        //   https://github.com/emscripten-core/emscripten/pull/16917\r\n        !ENVIRONMENT_IS_NODE &&\r\n        typeof fetch == 'function') {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        // Suppress closure warning here since the upstream definition for\r\n        // instantiateStreaming only allows Promise<Repsponse> rather than\r\n        // an actual Response.\r\n        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n        /** @suppress {checkTypes} */\r\n        var result = WebAssembly.instantiateStreaming(response, info);\r\n\r\n        return result.then(\r\n          receiveInstantiationResult,\r\n          function(reason) {\r\n            // We expect the most common failure cause to be a bad MIME type for the binary,\r\n            // in which case falling back to ArrayBuffer instantiation should work.\r\n            err('wasm streaming compile failed: ' + reason);\r\n            err('falling back to ArrayBuffer instantiation');\r\n            return instantiateArrayBuffer(receiveInstantiationResult);\r\n          });\r\n      });\r\n    } else {\r\n      return instantiateArrayBuffer(receiveInstantiationResult);\r\n    }\r\n  }\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\r\n  // to any other async startup actions they are performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this path.\r\n  if (Module['instantiateWasm']) {\r\n    try {\r\n      var exports = Module['instantiateWasm'](info, receiveInstance);\r\n      return exports;\r\n    } catch(e) {\r\n      err('Module.instantiateWasm callback failed with error: ' + e);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If instantiation fails, reject the module ready promise.\r\n  instantiateAsync().catch(readyPromiseReject);\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// Globals used by JS i64 conversions (see makeSetValue)\r\nvar tempDouble;\r\nvar tempI64;\r\n\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = {\r\n  \r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function callRuntimeCallbacks(callbacks) {\r\n      while (callbacks.length > 0) {\r\n        var callback = callbacks.shift();\r\n        if (typeof callback == 'function') {\r\n          callback(Module); // Pass the module as the first argument.\r\n          continue;\r\n        }\r\n        var func = callback.func;\r\n        if (typeof func == 'number') {\r\n          if (callback.arg === undefined) {\r\n            // Run the wasm function ptr with signature 'v'. If no function\r\n            // with such signature was exported, this call does not need\r\n            // to be emitted (and would confuse Closure)\r\n            getWasmTableEntry(func)();\r\n          } else {\r\n            // If any function with signature 'vi' was exported, run\r\n            // the callback with that signature.\r\n            getWasmTableEntry(func)(callback.arg);\r\n          }\r\n        } else {\r\n          func(callback.arg === undefined ? null : callback.arg);\r\n        }\r\n      }\r\n    }\r\n\r\n  function withStackSave(f) {\r\n      var stack = stackSave();\r\n      var ret = f();\r\n      stackRestore(stack);\r\n      return ret;\r\n    }\r\n  function demangle(func) {\r\n      warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');\r\n      return func;\r\n    }\r\n\r\n  function demangleAll(text) {\r\n      var regex =\r\n        /\\b_Z[\\w\\d_]+/g;\r\n      return text.replace(regex,\r\n        function(x) {\r\n          var y = demangle(x);\r\n          return x === y ? x : (y + ' [' + x + ']');\r\n        });\r\n    }\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */\r\n  function getValue(ptr, type = 'i8') {\r\n      if (type.endsWith('*')) type = 'i32';\r\n      switch (type) {\r\n        case 'i1': return HEAP8[((ptr)>>0)];\r\n        case 'i8': return HEAP8[((ptr)>>0)];\r\n        case 'i16': return HEAP16[((ptr)>>1)];\r\n        case 'i32': return HEAP32[((ptr)>>2)];\r\n        case 'i64': return HEAP32[((ptr)>>2)];\r\n        case 'float': return HEAPF32[((ptr)>>2)];\r\n        case 'double': return Number(HEAPF64[((ptr)>>3)]);\r\n        default: abort('invalid type for getValue: ' + type);\r\n      }\r\n      return null;\r\n    }\r\n\r\n  var wasmTableMirror = [];\r\n  function getWasmTableEntry(funcPtr) {\r\n      var func = wasmTableMirror[funcPtr];\r\n      if (!func) {\r\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n      }\r\n      assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\r\n      return func;\r\n    }\r\n\r\n  function handleException(e) {\r\n      // Certain exception types we do not treat as errors since they are used for\r\n      // internal control flow.\r\n      // 1. ExitStatus, which is thrown by exit()\r\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n      //    that wish to return to JS event loop.\r\n      if (e instanceof ExitStatus || e == 'unwind') {\r\n        return EXITSTATUS;\r\n      }\r\n      quit_(1, e);\r\n    }\r\n\r\n  function jsStackTrace() {\r\n      var error = new Error();\r\n      if (!error.stack) {\r\n        // IE10+ special cases: It does have callstack info, but it is only\r\n        // populated if an Error object is thrown, so try that as a special-case.\r\n        try {\r\n          throw new Error();\r\n        } catch(e) {\r\n          error = e;\r\n        }\r\n        if (!error.stack) {\r\n          return '(no stack trace available)';\r\n        }\r\n      }\r\n      return error.stack.toString();\r\n    }\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */\r\n  function setValue(ptr, value, type = 'i8') {\r\n      if (type.endsWith('*')) type = 'i32';\r\n      switch (type) {\r\n        case 'i1': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i8': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n        case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\r\n        case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n        case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n        default: abort('invalid type for setValue: ' + type);\r\n      }\r\n    }\r\n\r\n  function setWasmTableEntry(idx, func) {\r\n      wasmTable.set(idx, func);\r\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped\r\n      // functions so we need to call it here to retrieve the potential wrapper correctly\r\n      // instead of just storing 'func' directly into wasmTableMirror\r\n      wasmTableMirror[idx] = wasmTable.get(idx);\r\n    }\r\n\r\n  function stackTrace() {\r\n      var js = jsStackTrace();\r\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\r\n      return demangleAll(js);\r\n    }\r\n\r\n  function _abort() {\r\n      abort('native code called abort()');\r\n    }\r\n\r\n  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {\r\n    _emscripten_get_now = () => {\r\n      var t = process['hrtime']();\r\n      return t[0] * 1e3 + t[1] / 1e6;\r\n    };\r\n  } else _emscripten_get_now = () => performance.now();\r\n  ;\r\n\r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n      HEAPU8.copyWithin(dest, src, src + num);\r\n    }\r\n\r\n  function _emscripten_request_animation_frame_loop(cb, userData) {\r\n      function tick(timeStamp) {\r\n        if (getWasmTableEntry(cb)(timeStamp, userData)) {\r\n          requestAnimationFrame(tick);\r\n        }\r\n      }\r\n      return requestAnimationFrame(tick);\r\n    }\r\n\r\n  function getHeapMax() {\r\n      return HEAPU8.length;\r\n    }\r\n  \r\n  function abortOnCannotGrowMemory(requestedSize) {\r\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ' + HEAP8.length + ', (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0');\r\n    }\r\n  function _emscripten_resize_heap(requestedSize) {\r\n      var oldSize = HEAPU8.length;\r\n      requestedSize = requestedSize >>> 0;\r\n      abortOnCannotGrowMemory(requestedSize);\r\n    }\r\n\r\n  var SYSCALLS = {varargs:undefined,get:function() {\r\n        assert(SYSCALLS.varargs != undefined);\r\n        SYSCALLS.varargs += 4;\r\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\r\n        return ret;\r\n      },getStr:function(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      }};\r\n  function _fd_close(fd) {\r\n      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');\r\n    }\r\n\r\n  function convertI32PairToI53Checked(lo, hi) {\r\n      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32\r\n      assert(hi === (hi|0));                    // hi should be a i32\r\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\r\n    }\r\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\r\n      return 70;\r\n    }\r\n\r\n  var printCharBuffers = [null,[],[]];\r\n  function printChar(stream, curr) {\r\n      var buffer = printCharBuffers[stream];\r\n      assert(buffer);\r\n      if (curr === 0 || curr === 10) {\r\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\r\n        buffer.length = 0;\r\n      } else {\r\n        buffer.push(curr);\r\n      }\r\n    }\r\n  function flush_NO_FILESYSTEM() {\r\n      // flush anything remaining in the buffers during shutdown\r\n      _fflush(0);\r\n      if (printCharBuffers[1].length) printChar(1, 10);\r\n      if (printCharBuffers[2].length) printChar(2, 10);\r\n    }\r\n  function _fd_write(fd, iov, iovcnt, pnum) {\r\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n      var num = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        for (var j = 0; j < len; j++) {\r\n          printChar(fd, HEAPU8[ptr+j]);\r\n        }\r\n        num += len;\r\n      }\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    }\r\n\r\n  function _setTempRet0(val) {\r\n      setTempRet0(val);\r\n    }\r\nvar ASSERTIONS = true;\r\n\r\n\r\n\r\n/** @type {function(string, boolean=, number=)} */\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n}\r\n\r\nfunction intArrayToString(array) {\r\n  var ret = [];\r\n  for (var i = 0; i < array.length; i++) {\r\n    var chr = array[i];\r\n    if (chr > 0xFF) {\r\n      if (ASSERTIONS) {\r\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\r\n      }\r\n      chr &= 0xFF;\r\n    }\r\n    ret.push(String.fromCharCode(chr));\r\n  }\r\n  return ret.join('');\r\n}\r\n\r\n\r\nfunction checkIncomingModuleAPI() {\r\n  ignoredModuleProp('fetchSettings');\r\n}\r\nvar asmLibraryArg = {\r\n  \"abort\": _abort,\r\n  \"emscripten_get_now\": _emscripten_get_now,\r\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\r\n  \"emscripten_request_animation_frame_loop\": _emscripten_request_animation_frame_loop,\r\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\r\n  \"fd_close\": _fd_close,\r\n  \"fd_seek\": _fd_seek,\r\n  \"fd_write\": _fd_write,\r\n  \"setTempRet0\": _setTempRet0\r\n};\r\nvar asm = createWasm();\r\n/** @type {function(...*):?} */\r\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\r\n\r\n/** @type {function(...*):?} */\r\nvar _registerFunctionPointer_updateTimer = Module[\"_registerFunctionPointer_updateTimer\"] = createExportWrapper(\"registerFunctionPointer_updateTimer\");\r\n\r\n/** @type {function(...*):?} */\r\nvar _convertStringToAscii = Module[\"_convertStringToAscii\"] = createExportWrapper(\"convertStringToAscii\");\r\n\r\n/** @type {function(...*):?} */\r\nvar _main = Module[\"_main\"] = createExportWrapper(\"main\");\r\n\r\n/** @type {function(...*):?} */\r\nvar ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\r\n\r\n/** @type {function(...*):?} */\r\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function() {\r\n  return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function() {\r\n  return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = function() {\r\n  return (_emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function() {\r\n  return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\r\n\r\n/** @type {function(...*):?} */\r\nvar stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\r\n\r\n/** @type {function(...*):?} */\r\nvar stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\r\n\r\n\r\n\r\n\r\n\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nunexportedRuntimeFunction('ccall', false);\r\nModule[\"cwrap\"] = cwrap;\r\nunexportedRuntimeFunction('allocate', false);\r\nunexportedRuntimeFunction('UTF8ArrayToString', false);\r\nunexportedRuntimeFunction('UTF8ToString', false);\r\nunexportedRuntimeFunction('stringToUTF8Array', false);\r\nunexportedRuntimeFunction('stringToUTF8', false);\r\nunexportedRuntimeFunction('lengthBytesUTF8', false);\r\nunexportedRuntimeFunction('addOnPreRun', false);\r\nunexportedRuntimeFunction('addOnInit', false);\r\nunexportedRuntimeFunction('addOnPreMain', false);\r\nunexportedRuntimeFunction('addOnExit', false);\r\nunexportedRuntimeFunction('addOnPostRun', false);\r\nunexportedRuntimeFunction('addRunDependency', true);\r\nunexportedRuntimeFunction('removeRunDependency', true);\r\nunexportedRuntimeFunction('FS_createFolder', false);\r\nunexportedRuntimeFunction('FS_createPath', true);\r\nunexportedRuntimeFunction('FS_createDataFile', true);\r\nunexportedRuntimeFunction('FS_createPreloadedFile', true);\r\nunexportedRuntimeFunction('FS_createLazyFile', true);\r\nunexportedRuntimeFunction('FS_createLink', false);\r\nunexportedRuntimeFunction('FS_createDevice', true);\r\nunexportedRuntimeFunction('FS_unlink', true);\r\nunexportedRuntimeFunction('getLEB', false);\r\nunexportedRuntimeFunction('getFunctionTables', false);\r\nunexportedRuntimeFunction('alignFunctionTables', false);\r\nunexportedRuntimeFunction('registerFunctions', false);\r\nModule[\"addFunction\"] = addFunction;\r\nunexportedRuntimeFunction('removeFunction', false);\r\nunexportedRuntimeFunction('prettyPrint', false);\r\nunexportedRuntimeFunction('getCompilerSetting', false);\r\nunexportedRuntimeFunction('print', false);\r\nunexportedRuntimeFunction('printErr', false);\r\nunexportedRuntimeFunction('getTempRet0', false);\r\nunexportedRuntimeFunction('setTempRet0', false);\r\nunexportedRuntimeFunction('callMain', false);\r\nunexportedRuntimeFunction('abort', false);\r\nunexportedRuntimeFunction('keepRuntimeAlive', false);\r\nunexportedRuntimeFunction('wasmMemory', false);\r\nunexportedRuntimeFunction('warnOnce', false);\r\nunexportedRuntimeFunction('stackSave', false);\r\nunexportedRuntimeFunction('stackRestore', false);\r\nunexportedRuntimeFunction('stackAlloc', false);\r\nunexportedRuntimeFunction('AsciiToString', false);\r\nunexportedRuntimeFunction('stringToAscii', false);\r\nunexportedRuntimeFunction('UTF16ToString', false);\r\nunexportedRuntimeFunction('stringToUTF16', false);\r\nunexportedRuntimeFunction('lengthBytesUTF16', false);\r\nunexportedRuntimeFunction('UTF32ToString', false);\r\nunexportedRuntimeFunction('stringToUTF32', false);\r\nunexportedRuntimeFunction('lengthBytesUTF32', false);\r\nunexportedRuntimeFunction('allocateUTF8', false);\r\nunexportedRuntimeFunction('allocateUTF8OnStack', false);\r\nunexportedRuntimeFunction('ExitStatus', false);\r\nunexportedRuntimeFunction('intArrayFromString', false);\r\nunexportedRuntimeFunction('intArrayToString', false);\r\nunexportedRuntimeFunction('writeStringToMemory', false);\r\nunexportedRuntimeFunction('writeArrayToMemory', false);\r\nunexportedRuntimeFunction('writeAsciiToMemory', false);\r\nModule[\"writeStackCookie\"] = writeStackCookie;\r\nModule[\"checkStackCookie\"] = checkStackCookie;\r\nunexportedRuntimeFunction('ptrToString', false);\r\nunexportedRuntimeFunction('zeroMemory', false);\r\nunexportedRuntimeFunction('stringToNewUTF8', false);\r\nunexportedRuntimeFunction('getHeapMax', false);\r\nunexportedRuntimeFunction('abortOnCannotGrowMemory', false);\r\nunexportedRuntimeFunction('emscripten_realloc_buffer', false);\r\nunexportedRuntimeFunction('ENV', false);\r\nunexportedRuntimeFunction('ERRNO_CODES', false);\r\nunexportedRuntimeFunction('ERRNO_MESSAGES', false);\r\nunexportedRuntimeFunction('setErrNo', false);\r\nunexportedRuntimeFunction('inetPton4', false);\r\nunexportedRuntimeFunction('inetNtop4', false);\r\nunexportedRuntimeFunction('inetPton6', false);\r\nunexportedRuntimeFunction('inetNtop6', false);\r\nunexportedRuntimeFunction('readSockaddr', false);\r\nunexportedRuntimeFunction('writeSockaddr', false);\r\nunexportedRuntimeFunction('DNS', false);\r\nunexportedRuntimeFunction('getHostByName', false);\r\nunexportedRuntimeFunction('Protocols', false);\r\nunexportedRuntimeFunction('Sockets', false);\r\nunexportedRuntimeFunction('getRandomDevice', false);\r\nunexportedRuntimeFunction('traverseStack', false);\r\nunexportedRuntimeFunction('UNWIND_CACHE', false);\r\nunexportedRuntimeFunction('convertPCtoSourceLocation', false);\r\nunexportedRuntimeFunction('readAsmConstArgsArray', false);\r\nunexportedRuntimeFunction('readAsmConstArgs', false);\r\nunexportedRuntimeFunction('mainThreadEM_ASM', false);\r\nunexportedRuntimeFunction('jstoi_q', false);\r\nunexportedRuntimeFunction('jstoi_s', false);\r\nunexportedRuntimeFunction('getExecutableName', false);\r\nunexportedRuntimeFunction('listenOnce', false);\r\nunexportedRuntimeFunction('autoResumeAudioContext', false);\r\nunexportedRuntimeFunction('dynCallLegacy', false);\r\nunexportedRuntimeFunction('getDynCaller', false);\r\nunexportedRuntimeFunction('dynCall', false);\r\nunexportedRuntimeFunction('handleException', false);\r\nunexportedRuntimeFunction('runtimeKeepalivePush', false);\r\nunexportedRuntimeFunction('runtimeKeepalivePop', false);\r\nunexportedRuntimeFunction('callUserCallback', false);\r\nunexportedRuntimeFunction('maybeExit', false);\r\nunexportedRuntimeFunction('safeSetTimeout', false);\r\nunexportedRuntimeFunction('asmjsMangle', false);\r\nunexportedRuntimeFunction('asyncLoad', false);\r\nunexportedRuntimeFunction('alignMemory', false);\r\nunexportedRuntimeFunction('mmapAlloc', false);\r\nunexportedRuntimeFunction('writeI53ToI64', false);\r\nunexportedRuntimeFunction('writeI53ToI64Clamped', false);\r\nunexportedRuntimeFunction('writeI53ToI64Signaling', false);\r\nunexportedRuntimeFunction('writeI53ToU64Clamped', false);\r\nunexportedRuntimeFunction('writeI53ToU64Signaling', false);\r\nunexportedRuntimeFunction('readI53FromI64', false);\r\nunexportedRuntimeFunction('readI53FromU64', false);\r\nunexportedRuntimeFunction('convertI32PairToI53', false);\r\nunexportedRuntimeFunction('convertI32PairToI53Checked', false);\r\nunexportedRuntimeFunction('convertU32PairToI53', false);\r\nunexportedRuntimeFunction('reallyNegative', false);\r\nunexportedRuntimeFunction('unSign', false);\r\nunexportedRuntimeFunction('strLen', false);\r\nunexportedRuntimeFunction('reSign', false);\r\nunexportedRuntimeFunction('formatString', false);\r\nunexportedRuntimeFunction('setValue', false);\r\nModule[\"getValue\"] = getValue;\r\nunexportedRuntimeFunction('PATH', false);\r\nunexportedRuntimeFunction('PATH_FS', false);\r\nunexportedRuntimeFunction('SYSCALLS', false);\r\nunexportedRuntimeFunction('getSocketFromFD', false);\r\nunexportedRuntimeFunction('getSocketAddress', false);\r\nunexportedRuntimeFunction('JSEvents', false);\r\nunexportedRuntimeFunction('registerKeyEventCallback', false);\r\nunexportedRuntimeFunction('specialHTMLTargets', false);\r\nunexportedRuntimeFunction('maybeCStringToJsString', false);\r\nunexportedRuntimeFunction('findEventTarget', false);\r\nunexportedRuntimeFunction('findCanvasEventTarget', false);\r\nunexportedRuntimeFunction('getBoundingClientRect', false);\r\nunexportedRuntimeFunction('fillMouseEventData', false);\r\nunexportedRuntimeFunction('registerMouseEventCallback', false);\r\nunexportedRuntimeFunction('registerWheelEventCallback', false);\r\nunexportedRuntimeFunction('registerUiEventCallback', false);\r\nunexportedRuntimeFunction('registerFocusEventCallback', false);\r\nunexportedRuntimeFunction('fillDeviceOrientationEventData', false);\r\nunexportedRuntimeFunction('registerDeviceOrientationEventCallback', false);\r\nunexportedRuntimeFunction('fillDeviceMotionEventData', false);\r\nunexportedRuntimeFunction('registerDeviceMotionEventCallback', false);\r\nunexportedRuntimeFunction('screenOrientation', false);\r\nunexportedRuntimeFunction('fillOrientationChangeEventData', false);\r\nunexportedRuntimeFunction('registerOrientationChangeEventCallback', false);\r\nunexportedRuntimeFunction('fillFullscreenChangeEventData', false);\r\nunexportedRuntimeFunction('registerFullscreenChangeEventCallback', false);\r\nunexportedRuntimeFunction('JSEvents_requestFullscreen', false);\r\nunexportedRuntimeFunction('JSEvents_resizeCanvasForFullscreen', false);\r\nunexportedRuntimeFunction('registerRestoreOldStyle', false);\r\nunexportedRuntimeFunction('hideEverythingExceptGivenElement', false);\r\nunexportedRuntimeFunction('restoreHiddenElements', false);\r\nunexportedRuntimeFunction('setLetterbox', false);\r\nunexportedRuntimeFunction('currentFullscreenStrategy', false);\r\nunexportedRuntimeFunction('restoreOldWindowedStyle', false);\r\nunexportedRuntimeFunction('softFullscreenResizeWebGLRenderTarget', false);\r\nunexportedRuntimeFunction('doRequestFullscreen', false);\r\nunexportedRuntimeFunction('fillPointerlockChangeEventData', false);\r\nunexportedRuntimeFunction('registerPointerlockChangeEventCallback', false);\r\nunexportedRuntimeFunction('registerPointerlockErrorEventCallback', false);\r\nunexportedRuntimeFunction('requestPointerLock', false);\r\nunexportedRuntimeFunction('fillVisibilityChangeEventData', false);\r\nunexportedRuntimeFunction('registerVisibilityChangeEventCallback', false);\r\nunexportedRuntimeFunction('registerTouchEventCallback', false);\r\nunexportedRuntimeFunction('fillGamepadEventData', false);\r\nunexportedRuntimeFunction('registerGamepadEventCallback', false);\r\nunexportedRuntimeFunction('registerBeforeUnloadEventCallback', false);\r\nunexportedRuntimeFunction('fillBatteryEventData', false);\r\nunexportedRuntimeFunction('battery', false);\r\nunexportedRuntimeFunction('registerBatteryEventCallback', false);\r\nunexportedRuntimeFunction('setCanvasElementSize', false);\r\nunexportedRuntimeFunction('getCanvasElementSize', false);\r\nunexportedRuntimeFunction('demangle', false);\r\nunexportedRuntimeFunction('demangleAll', false);\r\nunexportedRuntimeFunction('jsStackTrace', false);\r\nunexportedRuntimeFunction('stackTrace', false);\r\nunexportedRuntimeFunction('getEnvStrings', false);\r\nunexportedRuntimeFunction('checkWasiClock', false);\r\nunexportedRuntimeFunction('flush_NO_FILESYSTEM', false);\r\nunexportedRuntimeFunction('dlopenMissingError', false);\r\nunexportedRuntimeFunction('setImmediateWrapped', false);\r\nunexportedRuntimeFunction('clearImmediateWrapped', false);\r\nunexportedRuntimeFunction('polyfillSetImmediate', false);\r\nunexportedRuntimeFunction('uncaughtExceptionCount', false);\r\nunexportedRuntimeFunction('exceptionLast', false);\r\nunexportedRuntimeFunction('exceptionCaught', false);\r\nunexportedRuntimeFunction('ExceptionInfo', false);\r\nunexportedRuntimeFunction('exception_addRef', false);\r\nunexportedRuntimeFunction('exception_decRef', false);\r\nunexportedRuntimeFunction('Browser', false);\r\nunexportedRuntimeFunction('setMainLoop', false);\r\nunexportedRuntimeFunction('wget', false);\r\nunexportedRuntimeFunction('FS', false);\r\nunexportedRuntimeFunction('MEMFS', false);\r\nunexportedRuntimeFunction('TTY', false);\r\nunexportedRuntimeFunction('PIPEFS', false);\r\nunexportedRuntimeFunction('SOCKFS', false);\r\nunexportedRuntimeFunction('_setNetworkCallback', false);\r\nunexportedRuntimeFunction('tempFixedLengthArray', false);\r\nunexportedRuntimeFunction('miniTempWebGLFloatBuffers', false);\r\nunexportedRuntimeFunction('heapObjectForWebGLType', false);\r\nunexportedRuntimeFunction('heapAccessShiftForWebGLHeap', false);\r\nunexportedRuntimeFunction('GL', false);\r\nunexportedRuntimeFunction('emscriptenWebGLGet', false);\r\nunexportedRuntimeFunction('computeUnpackAlignedImageSize', false);\r\nunexportedRuntimeFunction('emscriptenWebGLGetTexPixelData', false);\r\nunexportedRuntimeFunction('emscriptenWebGLGetUniform', false);\r\nunexportedRuntimeFunction('webglGetUniformLocation', false);\r\nunexportedRuntimeFunction('webglPrepareUniformLocationsBeforeFirstUse', false);\r\nunexportedRuntimeFunction('webglGetLeftBracePos', false);\r\nunexportedRuntimeFunction('emscriptenWebGLGetVertexAttrib', false);\r\nunexportedRuntimeFunction('writeGLArray', false);\r\nunexportedRuntimeFunction('AL', false);\r\nunexportedRuntimeFunction('SDL_unicode', false);\r\nunexportedRuntimeFunction('SDL_ttfContext', false);\r\nunexportedRuntimeFunction('SDL_audio', false);\r\nunexportedRuntimeFunction('SDL', false);\r\nunexportedRuntimeFunction('SDL_gfx', false);\r\nunexportedRuntimeFunction('GLUT', false);\r\nunexportedRuntimeFunction('EGL', false);\r\nunexportedRuntimeFunction('GLFW_Window', false);\r\nunexportedRuntimeFunction('GLFW', false);\r\nunexportedRuntimeFunction('GLEW', false);\r\nunexportedRuntimeFunction('IDBStore', false);\r\nunexportedRuntimeFunction('runAndAbortIfError', false);\r\nunexportedRuntimeSymbol('ALLOC_NORMAL', false);\r\nunexportedRuntimeSymbol('ALLOC_STACK', false);\r\n\r\nvar calledRun;\r\n\r\n/**\r\n * @constructor\r\n * @this {ExitStatus}\r\n */\r\nfunction ExitStatus(status) {\r\n  this.name = \"ExitStatus\";\r\n  this.message = \"Program terminated with exit(\" + status + \")\";\r\n  this.status = status;\r\n}\r\n\r\nvar calledMain = false;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!calledRun) run();\r\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\nfunction callMain(args) {\r\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\r\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\r\n\r\n  var entryFunction = Module['_main'];\r\n\r\n  args = args || [];\r\n  args.unshift(thisProgram);\r\n\r\n  var argc = args.length;\r\n  var argv = stackAlloc((argc + 1) * 4);\r\n  var argv_ptr = argv >> 2;\r\n  args.forEach((arg) => {\r\n    HEAP32[argv_ptr++] = allocateUTF8OnStack(arg);\r\n  });\r\n  HEAP32[argv_ptr] = 0;\r\n\r\n  try {\r\n\r\n    var ret = entryFunction(argc, argv);\r\n\r\n    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as\r\n    // execution is asynchronously handed off to a pthread.\r\n    // if we're not running an evented main loop, it's time to exit\r\n    exit(ret, /* implicit = */ true);\r\n    return ret;\r\n  }\r\n  catch (e) {\r\n    return handleException(e);\r\n  } finally {\r\n    calledMain = true;\r\n\r\n  }\r\n}\r\n\r\nfunction stackCheckInit() {\r\n  // This is normally called automatically during __wasm_call_ctors but need to\r\n  // get these values before even running any of the ctors so we call it redundantly\r\n  // here.\r\n  _emscripten_stack_init();\r\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n  writeStackCookie();\r\n}\r\n\r\n/** @type {function(Array=)} */\r\nfunction run(args) {\r\n  args = args || arguments_;\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n    stackCheckInit();\r\n\r\n  preRun();\r\n\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    if (calledRun) return;\r\n    calledRun = true;\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    preMain();\r\n\r\n    readyPromiseResolve(Module);\r\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n    if (shouldRunNow) callMain(args);\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(function() {\r\n      setTimeout(function() {\r\n        Module['setStatus']('');\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\nModule['run'] = run;\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var oldOut = out;\r\n  var oldErr = err;\r\n  var has = false;\r\n  out = err = (x) => {\r\n    has = true;\r\n  }\r\n  try { // it doesn't matter if it fails\r\n    flush_NO_FILESYSTEM();\r\n  } catch(e) {}\r\n  out = oldOut;\r\n  err = oldErr;\r\n  if (has) {\r\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\r\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\r\n  }\r\n}\r\n\r\n/** @param {boolean|number=} implicit */\r\nfunction exit(status, implicit) {\r\n  EXITSTATUS = status;\r\n\r\n  checkUnflushedContent();\r\n\r\n  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\r\n  if (keepRuntimeAlive() && !implicit) {\r\n    var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';\r\n    readyPromiseReject(msg);\r\n    err(msg);\r\n  }\r\n\r\n  procExit(status);\r\n}\r\n\r\nfunction procExit(code) {\r\n  EXITSTATUS = code;\r\n  if (!keepRuntimeAlive()) {\r\n    if (Module['onExit']) Module['onExit'](code);\r\n    ABORT = true;\r\n  }\r\n  quit_(code, new ExitStatus(code));\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\n// shouldRunNow refers to calling main(), not run().\r\nvar shouldRunNow = true;\r\n\r\nif (Module['noInitialRun']) shouldRunNow = false;\r\n\r\nrun();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return Module.ready\r\n}\r\n);\r\n})();\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);\n\n//# sourceURL=webpack://webpack-project/./src/webpack-emcc.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.ts");
/******/ 	
/******/ })()
;